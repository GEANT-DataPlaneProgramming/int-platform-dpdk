
# DPDK
    Spousteni dpdk (/home/paxyk/dpdk/dpdk-21.05/examples/pipeline/build)
        sudo ./pipeline --vdev=net_tap,iface=int_in --vdev=net_tap2,iface=int_out -- -s helloCli 
    
    Preklad
        p4c-dpdk vxlan.p4 -o vxlan.spec

    SWX
        pipeline PIPELINE0 port out 0 link OUTVI txq 0 bsz 1
        - id musi asi jit postupne, jinak se mu to nelibi

        v x.spec musi byt vsechny polozky ve strukturach zarovanne na nasobky 8
        tj:
            bit<8> OK
            bit<4> FAIL
        v key muze byt jen exact (nebo minimalne tomu vadi lpm)
    
    POZNAMKY
    pokud se pouziva --vdev... ifc je defaultne down
    - v helloworld dpdk to tak je
    - v pipe je normalne up ...

    Aby slo pouzit ifc je potreba ho nabindovat, ale jak pak poslu packety?? -> Muselo by to nejak byt v loopbacku
    S virtualnimi interfaci to cca funguje

    V psa je timestamp v psa_ingress_input_metadata_t, ale je to nejaky typ Timestamp_t, ktery nejde implicitne prevest
        na bit<64> -> jde udelat "static cast" ( (bit<64>) ), p4c-dpdk to prezvyka, ale vypada to, ze se tahle kostrukce
        pak nelibi SWX

    V metadatech nemuze byt header -> musi tam byt jen bit<X>

    Vypada to ze v key nemuze byt ruzne hlavicky napr
        table table_influx {
	    key {
	    	h.ipv4.srcAddr exact
	    	h.influx.egress_port_id exact
	    }
        Neprojde, ale pokud pouzijeme kazdou zvlast, je to v poradku. Navic pokud pouzijeme druhe pole napr h.ipv4.dstAddr
            taky neni zadny problem

    Jak testovat ??
        -> spustim prikaz vyse (./pipeline ...)
        -> spustim tcpdump na int_out
        -> tcpreplay na int_in

    Uprava tabulek "zvenku"
        pr. match 0x227a7920 action change
            match <pravidlo> action <akce> [parametry, ktere potrebuje akce]

    Vypada to ze se pouzivaji jen tyto metadata. S tim ze v kodu jsem je nenasla takze...
        struct metadata_t {
	        bit<32> psa_ingress_input_metadata_ingress_port
	        bit<8> psa_ingress_output_metadata_drop
	        bit<32> psa_ingress_output_metadata_egress_port
        }

    Pokud se SWX sekne na dyl (az po probe... jakmile tam naskoci TELEMETRIC hento...)
        zkontroluj jestli je spravne nazev nebo celkove cesta ke scriptu conzole
    
    Pri emitovani nevalidnich hlavicek se chova pofiderne
        - nekdy pres nej nic Neprojde
        - nekdy projdou nevalidni data
        - nekdy je mu to uplne jedno

    Necemu z toho se nelibi exit a return, respektive nenahlasi chyby ale neprovede se spravne 
        (return je schovany v podmince ale stejne se asi vykona -> nevim to jiste, vim jen ze se nedostanu za prikaz return
            i kdyz je v podmince, ktera nema probehnout, nebo druha moznost
                -> pri pouziti return se neaplikuji provedene zmeny)

    Constant entri nefunguje, bud se to spatne prelozi v p4c (nehlasi chybu) nebo to proste SWX neumi zpracovat

    SWX nejak blbne pokud neanbinduju zarizeni k dpdk i kdyz se toto zarizeni pak nepouzije na esprimu to jede v pohode, tam ale zase musime vytvorit jedno virtualni rozhrani Navic. -> protoze se cisluje od 0
    na nb tam bylo to nabindovane zarizeni, ktere bylo 0 a jelikoz na primu neni nic nabindovano tak jsou porty 0 a 1, ale ja v aplikaci pouzivam 1 2 .... takze klasicka programatorska chyba o jednicku :)

    setInvalid nejak blbne ?? ne tak to asi funguje spravne, ale proc mi tam zustava int node :(
        -> protoze se to nevyparsuje do tech hlavicek ? Protoze int_hdr se normalne odstrani

    pokud se do checksum prida 8b polozka dela to neplechu

    Pri pouzivani tabulek v egress casti se to nejak rozbije...
    Egress je celkove takovy nejaky rozbity

    prekladac prelozi header stack jen swx to nejak neprezvyka 
        -> prekladac tam totiz dava kontrolu na konec pole
            verify 0 error.StackOutOfBounds
        a to se swx nelibi
        se stackem to obecne nejak blbne, nejdou pak emitovat hlavicky (ethernet,ipv4,...) z nejakeho duvodu
        ->jen dusledek, chyba je jinde viz dalsi radek
        swx ma problem se zapornymi cisli asi a pracuje jen s uint?
            -> protoze pro vyraz x = x -1 se nageneruje instrukce add x 0xff a neni to funkcni pokud se instrukce predela na sub x 0x1 vse je v poradku
            -> take pokud se pouzije x = 4 - y. Vse je ok, pokud se pouzije x = z - y nageneruji se instrukce obracene a vznikne zaporne cislo, ktere dela problemy


    Muzu se pripojit na swx aplikaci pomoci telnet 0.0.0.0 8086
    V checksum mohou byt jen hlavicky, pokud tam je hodnota tak se to swx nelibi ani metadata not good
    8b hodnota v checksum nedela dobrotu, nebo spis kdyz ty hlavicky nejsou zarovnane na 16b

    !?!? sudo ethtool --offload enp0s31f6 rx off tx off

    kdyz dam do checksum 8b hodnotu, zarovna se na 16b tak ze se daji 2 nuly doprava tzn. 8b 01 bude 16b 01 00

    Kdyz dam do cksum celou hlavicku (ne vyjmenovani polozek), tak to pocita spatne
    Wire shark obcas nenahlasi spatnou delku packetu (mozna kdy je hodnota v policku mensi nez packet ?) a pak je spatnej checksum ?

    Pozor pokud by byl v packetu payload spatne se spocita checksum (asi) bylo by to potreba predelat na "odebiraci" checksum, kdy vezmem puvodni checksum
        a k nemu pricteme/odectem hlavicky/data, ktera je potreba

    Pokud je v poli misto pro vice hlavicek nez je aktualne v packetu (node-data/header stack) tak se to chova spatne
        -> protoze se to nezastavi -> protoze se spatne generuje odecitani. Deje se to u pocitani s konstatntamy
        kdyz je konstanta prvni je spatne poradi, kdyz druha vygeneruje se to jako scitani se zapornym cislem a pak vznikne chyba viz vyse
        Nejde to osidit lokalni promenou ani prirazenim cisla do metadat ve stejnem stavu, pokud to ale priradime do metadat jinde uz to funguje 

    Pokud neni cely stack validni neemitne se

    p4c-dpdk omezeni
        - se asi nelibi slozene logicke vyrazy ?? napr pouziti ampersantu

        - nepotporuje vice parametru pro vyber pri parsovani (transition (condition1, condition2)) - od 14.7.2021 by uz mel potporovat. Netestovano

        - neda se pouzit &&& pri vyberu kam pokracovat v parseru

        - verify problem
            Cannot unify type 'bit<8>' with type 'bool'
            ---- Originating from:
            ../../p4-harakiry/int/parser.p4(56): Source expression 'h.int_shim.len' produces a result of type 'bit<8>' which cannot be assigned to a left-value with type 'bool'
                  verify(hdr.int_shim.len >= 8w3, error.INTShimLenTooShort); // TODO
                         ^^^^^^^^^^^^^^^^

        - Z nejakeho duvodu to nechce nagenerovat extern
        - Default akce s parametry funguje nejak pofiderne... nesla nastavit, kricelo to
            , ze ma moc argumentu (pritom jsou ok)
            , ale pri nastaveni default akce bez parametru, ve ktere se vola akce s parametry
            (ta o ktere se zde celou dobu mluvi)
            vsechno bylo v poradku

        - nemuzu nasobit napr hdr.int_ingress_tstamp.ingress_tstamp = meta.ingress_tstamp * 1000;
            zahlasi chybu tzn nejde nasobit konstatnta a promenna nebo vseobecne promenna nemuze byt operandem pri nasobeni

        - klonovani

        - nezna truncate

        - kdyz svevolne odstrani nejakou tabulku (je nepouzita) SWX pak protestuje -> respektive nefunguje spravne

        - v parser casti se mu nelibi toto if(mask_0003 == 8) tmp_mask = 8; Nepomuzou ani zavorky ani pridani else
            stale hlasi Compiler Bug: tmp = h.int_header.instruction_mask1 == 8 ? 1 : 0; not implemented

        - metadata se stejnym jmenem delaji paseku, ale zase jen obcas...

        - jina metadata nez "hlavni" jsou problem ??
            - pise ze nenajde definici, ale kdyz se zada spatny atribut tak to krici, ze neni soucasti teto struktury...

        - nejde pouzit zvlast napsany parser, napise to ze tam jsou loops, ale kdyz ten sami parsek nakopiruju na 2 mista (do ingress a egress aka tam kde chci volat funkci) tak to normalne funguje

# JINE
na primu musi byt jeden interface Navic a musim cislovat ty tap. zase neni potreba bindovat
ve specifikaci je maska rozdelena do 4 casti po 4 bitech
    instructin_mask_0003;   (00 - od ktereho bitu 03 po ktery bit) -> 0-3
    instructin_mask_0407;                                             4-7
    instructin_mask_0811;                                             8-11
    instructin_mask_1215;                                             12-15


V p4c-dpdk neiplementuje mark_to_drop